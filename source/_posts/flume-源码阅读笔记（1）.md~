title: "flume 源码阅读笔记（1）"
date: 2015-07-08 20:15:48
tags: flume 源码
---
#1 . 启动脚本
最开始肯定是从启动脚本flume-ng下手了
``` shell
FLUME_AGENT_CLASS="org.apache.flume.node.Application" # 这个是主要入口
FLUME_AVRO_CLIENT_CLASS="org.apache.flume.client.avro.AvroCLIClient"
FLUME_VERSION_CLASS="org.apache.flume.tools.VersionInfo"
FLUME_TOOLS_CLASS="org.apache.flume.tools.FlumeToolsMain"
```

***

#2. 主程序入口Application
```java
 Options options = new Options();
 ..... //一大堆命令行参数

  CommandLineParser parser = new GnuParser();
  CommandLine commandLine = parser.parse(options, args);
  // 以上两行，对命令行参数解析完毕

  // 打印帮助信息
  if (commandLine.hasOption('h')) {
    new HelpFormatter().printHelp("flume-ng agent", options, true);
    return;
  }

  String agentName = commandLine.getOptionValue('n');
  boolean reload = !commandLine.hasOption("no-reload-conf");

  // 是否有zookeeper的相关配置
  if (commandLine.hasOption('z') || commandLine.hasOption("zkConnString")) {
    isZkConfigured = true;
  }
  
  // 主角登场
  Application application = null;
  if (isZkConfigured) {
    // get options
    String zkConnectionStr = commandLine.getOptionValue('z');
    String baseZkPath = commandLine.getOptionValue('p');

    if (reload) {
      EventBus eventBus = new EventBus(agentName + "-event-bus");
      List<LifecycleAware> components = Lists.newArrayList();
      PollingZooKeeperConfigurationProvider zookeeperConfigurationProvider =
        new PollingZooKeeperConfigurationProvider(
          agentName, zkConnectionStr, baseZkPath, eventBus);
      components.add(zookeeperConfigurationProvider);
      application = new Application(components);
      eventBus.register(application);
    } else {
      StaticZooKeeperConfigurationProvider zookeeperConfigurationProvider =
        new StaticZooKeeperConfigurationProvider(
          agentName, zkConnectionStr, baseZkPath);
      application = new Application();
      application.handleConfigurationEvent(zookeeperConfigurationProvider
        .getConfiguration());
    }
  } else {
    File configurationFile = new File(commandLine.getOptionValue('f'));
    /*
     * 如果配置文件不存在，就直接报错
     */
    if (!configurationFile.exists()) {
      ...
    }
    List<LifecycleAware> components = Lists.newArrayList();

    if (reload) {
      EventBus eventBus = new EventBus(agentName + "-event-bus");
      PollingPropertiesFileConfigurationProvider configurationProvider =
        new PollingPropertiesFileConfigurationProvider(
          agentName, configurationFile, eventBus, 30);
      components.add(configurationProvider);
      application = new Application(components);
      eventBus.register(application);
    } else {
      PropertiesFileConfigurationProvider configurationProvider =
        new PropertiesFileConfigurationProvider(
          agentName, configurationFile);
      // 下面为典型启动过程
      application = new Application();
      application.handleConfigurationEvent(configurationProvider
        .getConfiguration());
    }
  }
  application.start(); // 程序启动

  // 后面是shutdown hook，作清理工作
```
综上来看，有营养的代码很少，就是读个配置文件，然后直接就启动程序了。那么application的初始化和start方法里都有些什么操作呢？

```java
  // 1. 构造方法里只是注册一个LifecycleSupervisor，也就是管理生命周期的
  public Application() {
    this(new ArrayList<LifecycleAware>(0));
  }

  public Application(List<LifecycleAware> components) {
    this.components = components;
    supervisor = new LifecycleSupervisor();
  }

 // 2. 根据conf重启所有components
  @Subscribe
  public synchronized void handleConfigurationEvent(MaterializedConfiguration conf) {
    stopAllComponents();
    startAllComponents(conf); // 这个conf来自于配置文件，你懂得，这些component肯定就是source channel sink 之类的了
  }
  
  // 3. 使用1中初始化的supervisor对所有component进行监管
  public synchronized void start() {
    for(LifecycleAware component : components) {
      supervisor.supervise(component,
          new SupervisorPolicy.AlwaysRestartPolicy(), LifecycleState.START);
    }
  }
```
好，启动component的入口也明晰了
```java
private void startAllComponents(MaterializedConfiguration materializedConfiguration) {

    for (Entry<String, Channel> entry :
      materializedConfiguration.getChannels().entrySet()) {
      try{
        logger.info("Starting Channel " + entry.getKey());
        // 1. 将channel交给supervisor来进行生命周期管理，这里是启动
        supervisor.supervise(entry.getValue(),
            new SupervisorPolicy.AlwaysRestartPolicy(), LifecycleState.START);
      } catch (Exception e){
        logger.error("Error while starting {}", entry.getValue(), e);
      }
    }

    // 2. 启动sink 和 souce之前，确保所有的channel无误地启动完毕
    for(Channel ch: materializedConfiguration.getChannels().values()){
      while(ch.getLifecycleState() != LifecycleState.START
          && !supervisor.isComponentInErrorState(ch)){
          logger.info("Waiting for channel: " + ch.getName() +
              " to start. Sleeping for 500 ms");
          Thread.sleep(500);
      }
    }

    // 3. 同上方式，启动sink
    
    // 4. 同上方式，启动source

    // 监控： 目前支持ganlia和http jetty两种，需要在命令行指定type
    // $ bin/flume-ng agent --conf-file example.conf --name a1 -Dflume.monitoring.type=ganglia -Dflume.monitoring.hosts=com.example:1234,com.example2:5455
    this.loadMonitoring();
  }

```
至此启动流程就完毕了。太简单了也~~~
